@page "/nearest-gym"
@inject IJSRuntime JS
@inject HttpClient Http
@inject NavigationManager Navigation
@using GymTracker.Models
@rendermode InteractiveServer

<h3>üìç Nearest Gym </h3>

<button id="blazorGetLocationBtn" class="btn btn-primary" @onclick="GetLocation" disabled="@isLoading">
    @if (isLoading)
    {
        <span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span>
    <span class="sr-only"> Loading...</span>
    <span>&nbsp;Detecting...</span>
    }
    else
    {
        <span>Get My Location</span>
    }
</button>

<!-- locationMessage display removed -->
<!-- debugInfo removed -->

@if (nearestGyms?.Any() == true)
{
    <h5 class="mt-3">Nearby gyms</h5>
    <ul class="list-group">
        @for (int i = 0; i < nearestGyms.Count; i++)
        {
            var g = nearestGyms[i];
            // Match by Name, Latitude, and Longitude only
            int markerIndex = gyms.FindIndex(x => x.Name == g.Name && x.Latitude == g.Latitude && x.Longitude == g.Longitude);
            if (markerIndex == -1) markerIndex = 0; // fallback to first marker if not found
            <li class="list-group-item d-flex justify-content-between align-items-start" style="cursor:pointer;" @onclick="() => PanToMarker(markerIndex)">
                <div>
                    <div class="fw-bold">@g.Name</div>
                    <div class="text-muted small">@g.Address</div>
                </div>
                <span class="badge bg-primary rounded-pill">@String.Format("{0:0.0} mi", g.DistanceMiles)</span>
            </li>
        }
    </ul>
}
else if (!string.IsNullOrEmpty(locationMessage) && !isLoading)
{
    <div class="mt-3 text-muted">No nearby gyms found. Click the button to detect your location.</div>
}

<!-- Fallback: attach a DOM click handler in case Blazor event wiring isn't active -->
<script>
    (function () {
        try {
            const btn = document.getElementById('blazorGetLocationBtn');
            const msgEl = document.getElementById('blazorLocationMessage');
            if (!btn) return;

            btn.addEventListener('click', function (e) {
                // If Blazor handled it, this will be harmless; otherwise this gives a fallback
                try {
                    if (msgEl) msgEl.textContent = 'Fallback: detecting location...';
                    window.getUserLocation().then(p => {
                        if (msgEl) msgEl.textContent = `Lat: ${p.Latitude}, Lng: ${p.Longitude}`;
                        console.log('Fallback: got position', p);

                        // If map helper is present, add a user marker and pan to it
                        try {
                            if (window.googleMaps && typeof window.googleMaps.addUserMarker === 'function') {
                                window.googleMaps.addUserMarker(p.Latitude, p.Longitude);
                            }
                        } catch (mapErr) {
                            console.error('Fallback map update error', mapErr);
                        }

                    }).catch(err => {
                        if (msgEl) msgEl.textContent = 'Fallback error: ' + err;
                        console.error('Fallback error', err);
                    });
                }
                catch (err) {
                    console.error('Fallback click handler error', err);
                }
            });
        }
        catch (err) {
            console.error('Error installing fallback click handler', err);
        }
    })();
</script>

<div class="mt-3">
    <GoogleMap TMarker="object" CenterLat="33.8703" CenterLng="-117.9243" Height="400px" Width="100%" Zoom="13" Markers="mapMarkers" />
</div>

@code {
    private string? locationMessage = string.Empty;
    // debugInfo removed
    private bool isLoading = false;

    private async Task GetLocation()
    {
        // Immediate feedback so we know the Blazor click handler fired
        isLoading = true;
        locationMessage = "Blazor handler invoked...";
        await JS.InvokeVoidAsync("console.log", "Blazor: GetLocation handler invoked");
        StateHasChanged();

        try
        {
            // Call the global function exposed in wwwroot/geolocation.js
            // First call it as raw object to log the result for debugging
            var raw = await JS.InvokeAsync<object>("getUserLocation");
            await JS.InvokeVoidAsync("console.log", "Blazor: raw result", raw);


            // Then map to the typed object
            var pos = await JS.InvokeAsync<Geolocation>("getUserLocation");
            locationMessage = $"Lat: {pos.Latitude}, Lng: {pos.Longitude}";

            // Try fetching nearby gyms from server-side Places proxy
            try
            {
                var apiUrl = $"{Navigation.BaseUri}api/places/nearby?lat={pos.Latitude}&lng={pos.Longitude}&radius=5000";
                var apiGyms = await Http.GetFromJsonAsync<List<Gym>>(apiUrl);
                // Log the API result for debugging
                await JS.InvokeVoidAsync("console.log", "API nearby gyms returned count:", apiGyms == null ? 0 : apiGyms.Count);
                await JS.InvokeVoidAsync("console.log", "API gyms raw:", apiGyms);

                if (apiGyms != null && apiGyms.Count > 0)
                {
                    gyms = apiGyms;

                    // Update map markers to show the fetched gyms --- wait for googleMaps helper first
                    var markers = gyms.Select(g => new { name = g.Name, address = g.Address, latitude = g.Latitude, longitude = g.Longitude }).ToArray();
                    await JS.InvokeVoidAsync("console.log", "About to call googleMaps.addMarkers with marker count:", markers.Length);
                    if (await WaitForGoogleMapsAsync())
                    {
                        try
                        {
                            // Ensure the map has finished initializing (drains any queued requests) before adding markers
                            try { await JS.InvokeAsync<object>("googleMaps.ensureReady"); } catch { /* ignore if ensureReady not present */ }
                            await JS.InvokeVoidAsync("googleMaps.addMarkers", markers);
                        }
                        catch (JSException jsEx)
                        {
                            await JS.InvokeVoidAsync("console.error", "JSException calling googleMaps.addMarkers:", jsEx.Message, jsEx.StackTrace);
                        }
                    }
                    else
                    {
                        await JS.InvokeVoidAsync("console.warn", "googleMaps helper not available when attempting to add markers");
                    }
                }
            }
            catch (Exception ex)
            {
                await JS.InvokeVoidAsync("console.error", "Failed to fetch nearby gyms", ex.Message);
            }

            // Compute nearest gyms from the (possibly updated) gyms list
            await ComputeNearestGymsAsync(pos.Latitude, pos.Longitude);

            // Add a user marker and re-center the map if the helper is available
            try
            {
                // Ensure map is ready then add a simple user marker via google maps helper
                try { await JS.InvokeAsync<object>("googleMaps.ensureReady"); } catch { /* ignore if ensureReady not present */ }
                await JS.InvokeVoidAsync("googleMaps.addUserMarker", pos.Latitude, pos.Longitude);
            }
            catch (JSException) { /* ignore if map helper is not present */ }
        }
        catch (JSException jsex)
        {
            locationMessage = "JS error: " + jsex.Message + "\n" + jsex.StackTrace;
            await JS.InvokeVoidAsync("console.error", "Blazor JSException:", jsex.Message, jsex.StackTrace);
        }
        catch (Exception ex)
        {
            locationMessage = "Error: " + ex.Message + "\n" + ex.StackTrace;
            await JS.InvokeVoidAsync("console.error", "Blazor Exception:", ex.Message, ex.StackTrace);
        }
        finally
        {
            isLoading = false;
            StateHasChanged();
        }
    }

    public class Geolocation
    {
        public double Latitude { get; set; }
        public double Longitude { get; set; }
    }

    // Gyms list populated at runtime from server-side API or local fallback
    private List<Gym> gyms = new();
    private IEnumerable<object> mapMarkers => gyms.Select(g => new { name = g.Name, address = g.Address, latitude = g.Latitude, longitude = g.Longitude, rating = g.Rating, hours = g.Hours, photoUrl = g.PhotoUrl });

    private List<NearestGymResult> nearestGyms = new();

    private async Task ComputeNearestGymsAsync(double userLat, double userLng)
    {
        //debug
        await Task.Delay(1000);

            nearestGyms = gyms
            .Select(g => new NearestGymResult
            {
                Name = g.Name,
                Address = g.Address,
                DistanceMiles = HaversineDistanceMiles(userLat, userLng, g.Latitude, g.Longitude),
                Latitude = g.Latitude,
                Longitude = g.Longitude
            })
            .OrderBy(r => r.DistanceMiles)
            .ToList();

        StateHasChanged();
    }

    private static double HaversineDistanceMiles(double lat1, double lon1, double lat2, double lon2)
    {
        // Compute distance in kilometers then convert to miles
        double R = 6371; // Earth radius in km
        double dLat = ToRadians(lat2 - lat1);
        double dLon = ToRadians(lon2 - lon1);
        double a = Math.Sin(dLat / 2) * Math.Sin(dLat / 2) +
                   Math.Cos(ToRadians(lat1)) * Math.Cos(ToRadians(lat2)) *
                   Math.Sin(dLon / 2) * Math.Sin(dLon / 2);
        double c = 2 * Math.Atan2(Math.Sqrt(a), Math.Sqrt(1 - a));
        double km = R * c;
        return km * 0.621371; // convert km to miles
    }

    private static double ToRadians(double angle) => (Math.PI / 180) * angle;

    private class NearestGymResult
    {
        public string Name { get; set; } = string.Empty;
        public string Address { get; set; } = string.Empty;
        public double DistanceMiles { get; set; }
        public double Latitude { get; set; }
        public double Longitude { get; set; }
    }

    // Map initialization is now handled by the GoogleMap component

    private async Task<bool> WaitForGoogleMapsAsync(int attempts = 30, int delayMs = 100)
    {
        for (int i = 0; i < attempts; i++)
        {
            try
            {
                // Check that google and google.maps and our helper are present
                var exists = await JS.InvokeAsync<bool>("eval", "(typeof window.google !== 'undefined' && typeof window.google.maps !== 'undefined' && typeof window.googleMaps !== 'undefined')");
                if (exists) return true;
            }
            catch (JSException)
            {
                // ignore and retry
            }
            await Task.Delay(delayMs);
        }
        return false;
    }

    // Keep the fallback click handler, but don't show availability checks on render

    private async Task PanToMarker(int index)
    {
        if (index >= 0 && index < gyms.Count)
        {
            var gym = gyms[index];
            await JS.InvokeVoidAsync("console.log", $"PanToMarker: index={index}, Name={gym.Name}, Lat={gym.Latitude}, Lng={gym.Longitude}");
        }
        else
        {
            await JS.InvokeVoidAsync("console.log", $"PanToMarker: index={index} (out of range)");
        }
        await JS.InvokeVoidAsync("googleMaps.panToMarker", index);
    }
}
